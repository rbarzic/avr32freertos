/*      AVR32 specific FreeRTOS port.c file      
        Adaptated from ARM7 port.c/portISR.c files Copyright (C) 2003-2005 Richard Barry.
        AVR32 adaptation  Copyright (C) 2006 Ronan BARZIC  

	This file is part of the AVR32 port of FreeRTOS - It is
	available with the same license as FreeRTOS :   

	FreeRTOS is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	FreeRTOS is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with FreeRTOS; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

	A special exception to the GPL can be applied should you wish to distribute
	a combined work that includes FreeRTOS, without being obliged to provide
	the source code for any proprietary components.  See the licensing section 
	of http://www.FreeRTOS.org for full details of how and when the exception
	can be applied.

	***************************************************************************
	See http://www.FreeRTOS.org for documentation, latest information, license 
	and contact details.  Please ensure to read the configuration and relevant 
	port sections of the online documentation.
	***************************************************************************
*/


/* Scheduler includes. */
#include "FreeRTOS.h"
#include "task.h"

#include "avr32_circuit.h"



/* Constants required to setup the task context. */
#define portINITIAL_SPSR				( ( portSTACK_TYPE ) 0x00400000 ) /* AVR32 : I3M=0 I2M=0 I1M=0 I0M=0, GM=0 */
#define portINSTRUCTION_SIZE			        ( ( portSTACK_TYPE ) 0 )

// FIXME -- should it be the same ?
#define portNO_CRITICAL_SECTION_NESTING	                ( ( portSTACK_TYPE ) 0 )
#define portNO_CRITICAL_NESTING		                ( ( unsigned portLONG ) 0 )



volatile unsigned portLONG ulCriticalNesting = 0UL;

void vPortISRStartFirstTask( void )
{
  portRESTORE_CONTEXT_NOIRQ();
}


/* 
 * The ISR used for the scheduler tick depends on whether the cooperative or
 * the preemptive scheduler is being used.
 */

#if configUSE_PREEMPTION == 0

	/* The cooperative scheduler requires a normal IRQ service routine to 
	simply increment the system tick. */
	void vNonPreemptiveTick( void ) __attribute__ ((interrupt ("IRQ")));
	void vNonPreemptiveTick( void )
	{		
		vTaskIncrementTick();
	
	}

#else



void prvAcknowledgeTimerInterrupt( void );
	/* The preemptive scheduler is defined as "naked" as the full context is
	saved on entry as part of the context switch. */
void vPreemptiveTick( void ) __attribute__((naked)) __attribute__ ((section (".handlers")));
void vPreemptiveTick( void )
{
  
  
  /* Save the context of the interrupted task. */
	  portSAVE_CONTEXT(EX_INT0);	

	  prvAcknowledgeTimerInterrupt();
            portENTER_CRITICAL();
          vTaskIncrementTick();
            
	  vTaskSwitchContext();
            portEXIT_CRITICAL();
	  portRESTORE_CONTEXT(EX_INT0);
}

#endif



void SCALLYield( void ) __attribute__((naked));
void SCALLYield( void )
{
  /* Save the context of the interrupted task. */
  portSAVE_CONTEXT_SCALL;	
  
  vTaskSwitchContext();
  
  portRESTORE_CONTEXT_SCALL;
}


/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
void vPortEnterCritical( void )
{
	/* Disable interrupts as per portDISABLE_INTERRUPTS(); 								*/


  DISABLE_ALL_INTERRUPTS;
  /* Now interrupts are disabled ulCriticalNesting can be accessed 
     directly.  Increment ulCriticalNesting to keep a count of how many times
     portENTER_CRITICAL() has been called. */
  ulCriticalNesting++;
}

void vPortExitCritical( void )
{
	if( ulCriticalNesting > portNO_CRITICAL_NESTING )
	{
		/* Decrement the nesting count as we are leaving a critical section. */
		ulCriticalNesting--;

		/* If the nesting level has reached zero then interrupts should be
		re-enabled. */
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
		{
			/* Enable interrupts as per
			   portEXIT_CRITICAL(). */
		  ENABLE_ALL_INTERRUPTS;
		}
	}
}




/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt( void );

/*-----------------------------------------------------------*/

/* 
 * Initialise the stack of a task to look exactly as if a call to 
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
portSTACK_TYPE *pxOriginalTOS;
         
	pxOriginalTOS = pxTopOfStack;

	/* Setup the initial stack of the task.  The stack is set exactly as 
	expected by the portRESTORE_CONTEXT() macro. */

	
	/* When the task starts is will expect to find the function parameter in
	R0. */
	// *pxTopOfStack = ( portSTACK_TYPE ) pvParameters; /* R0 */
	// pxTopOfStack--;

	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xCAFEBAFE + portINSTRUCTION_SIZE; /* LR - should never be used*/	
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;	/* R0 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;	/* R1 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;	/* R2 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;	/* R3 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;	/* R4 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;	/* R5 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;	/* R6 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;	/* R7 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;	/* R8 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;	/* R9 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;	/* R10 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;	/* R11 */
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;	/* R12*/


	*pxTopOfStack-- = ( portSTACK_TYPE ) pxOriginalTOS;	/* SP */
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* PC */





	/* The last thing onto the stack is the status register, which is set for
	system mode, with interrupts enabled. */
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SPSR;

	/* Some optimisation levels use the stack differently to others.  This 
	means the interrupt flags cannot always be stored on the stack and will
	instead be stored in a variable, which is then saved as part of the
	tasks context. */
	*pxTopOfStack = portNO_CRITICAL_SECTION_NESTING;

	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	vPortISRStartFirstTask();	

	/* Should not get here! */
	return 0;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR32 port will require this function as there
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/






static void prvSetupTimerInterrupt( void )
{
  unsigned long timer0group = AVR32_TIMER0_IRQ0/32;
  
#if configUSE_PREEMPTION == 0


extern void ( vPortNonPreemptiveTick )( void );
  volatile avr32_intc_t *intc = &AVR32_INTC;

  unsigned long addr2 = (unsigned long) &vPortNonPreemptiveTick;

  // adress of interrupt is EVBA | Offset, not EVBA + Offset
  // EVBA is set to 0x200, handlers start at 0x600
  // 0x200  | 0x600 = 0x600 !!
  // offset is 14 bits -> so we mask out MSB
  unsigned long  offset;
  offset = addr2 & 0x03FFF;

 
  intc->intpr[timer0group] = (INT0 << INTLEV) | (offset);

 
#else
 
  extern void ( vPreemptiveTick )( void );
  volatile avr32_intc_t *intc = &AVR32_INTC;

  unsigned long addr2 = (unsigned long) &vPreemptiveTick;

  // adress of interrupt is EVBA | Offset, not EVBA + Offset
  // EVBA is set to 0x200, handlers start at 0x600
  // 0x200  | 0x600 = 0x600 !!
  // offset is 14 bits -> so we mask out MSB
  unsigned long  offset;
  offset = addr2 & 0x03FFF;

 
  intc->intpr[timer0group] = (INT0 << INTLEV) | (offset);

#endif


  
    /* Start Timer */
    volatile avr32_timer_t *timer0 = &AVR32_TIMER0;

    
    
    union {
      unsigned long                  cmr       ;//0x0004
      avr32_timer_cmr_t              CMR       ;
    } u_cmr;

    union {
      unsigned long                  ccr       ;//0x0000
      avr32_timer_ccr_t              CCR       ;
    } u_ccr;
    u_cmr.cmr = 0;
    u_cmr.CMR.waveform.wave                = 1;
    u_cmr.CMR.waveform.tcclks = 1;  // Timer clock 2 (apbb/4)
    u_cmr.CMR.waveform.wavsel  = 2; // upmode with automatic
					 // trigger on RC compare
    timer0->channel[0].cmr = u_cmr.cmr;

    //    timer0->channel[0].rc = 0x1D4C; // apbb/4 = 30MHz/4 = 7.5MHz
    // 1 IT/ms -> count to 7500 -> 0x1D4C
    // 20MHz -> 5MHz -> 5000/ms -> 0x1388
   timer0->channel[0].rc = 0x1388; 

    union {
          unsigned long                  ier       ;//0x0024
          avr32_timer_ier_t              IER       ;
    } u_ier ;
    u_ier.ier = 0;
    //u_ier.IER.covfs = 1;
    u_ier.IER.cpcs = 1;
    timer0->channel[0].ier = u_ier.ier;
    u_ccr.ccr = 0;

    u_ccr.CCR.clken = 1;
    u_ccr.CCR.swtrg = 1;
    timer0->channel[0].ccr = u_ccr.ccr;
    prvAcknowledgeTimerInterrupt();
  



}

void prvAcknowledgeTimerInterrupt( void ) {
   volatile avr32_timer_t *timer0 = &AVR32_TIMER0;
   unsigned long  flag; // For debugging
  
   // flag = timer0->channel[0].SR.covfs;
   flag = timer0->channel[0].SR.cpcs;
}

void EnableTimerInterrupt( void ) {
   volatile avr32_timer_t *timer0 = &AVR32_TIMER0;
   
   union {
          unsigned long                  ier       ;//0x0024
          avr32_timer_ier_t              IER       ;
    } u_ier ;
   u_ier.ier =0;
   //u_ier.IER.covfs = 1;
   u_ier.IER.cpcs = 1;
   timer0->channel[0].ier = u_ier.ier;
}

void DisableTimerInterrupt( void ) {
   volatile avr32_timer_t *timer0 = &AVR32_TIMER0;
   union {
          unsigned long                  idr       ;
          avr32_timer_idr_t              IDR       ;
    } u_idr ;
   u_idr.idr =0;
   // u_idr.IDR.covfs = 1;
   u_idr.IDR.cpcs = 1;

   timer0->channel[0].idr = u_idr.idr;
}

void EnableTimerCount( void ) {
   volatile avr32_timer_t *timer0 = &AVR32_TIMER0;
   // FIXME - potential GCC bug
   timer0->channel[0].CCR.clken = 1;
}

void DisableTimerCount( void ) {
   volatile avr32_timer_t *timer0 = &AVR32_TIMER0;
   union {
      unsigned long                  ccr       ;//0x0000
      avr32_timer_ccr_t              CCR       ;
    } u_ccr;

    u_ccr.ccr = timer0->channel[0].ccr;
    u_ccr.CCR.clken = 1;

    timer0->channel[0].ccr = u_ccr.ccr;

}

void TimerStart( void ) {
   volatile avr32_timer_t *timer0 = &AVR32_TIMER0;
   // FIXME - potential GCC bug
    union {
      unsigned long                  ccr       ;//0x0000
      avr32_timer_ccr_t              CCR       ;
    } u_ccr;

    u_ccr.ccr = timer0->channel[0].ccr;
    u_ccr.CCR.swtrg = 1;
    timer0->channel[0].ccr = u_ccr.ccr;
}







